
{-
The module demonstrates the use of ply-ctl for importing scripts, preserving Plutarch type info.

So Plutarch scripts are stored in files using "ply" library. 
The produced ".plutus" files contain script type information (validator/minting policy, what are the unapplied params).
To restore the type information when scripts are imported back from the files, one can use the "ply-ctl" library.
The below module demostrates that. In the context of the scaffold it's alternative to direct use of "Maybe PlutusScript" scripts exported from the autogenerated module Scripts.purs.
-}
module PlyScripts (makePasswordValidator, makeSimplePolicy) where

import Aeson (decodeAeson, parseJsonStringToAeson)
import Contract.Prelude (Either(..), (>>>))
import Contract.Scripts (MintingPolicy(..), Validator(..))
import Contract.Value (TokenName)
import Control.Monad.Error.Class (throwError)
import Ctl.Internal.Types.ByteArray (ByteArray)
import Data.Bifunctor (lmap)
import Ply.Apply (applyParam)
import Ply.Reify (class ReifyParams, class ReifyRole, reifyTypedScript)
import Ply.TypeList (Cons, Nil, TyList)
import Ply.Types (AsData, MintingPolicyRole, ScriptRole, TypedScript, TypedScriptEnvelope, ValidatorRole, toPlutusScript)
import Prelude (bind, pure, show, ($), (<<<), (<>))
import Scripts (password_validator_envelope, simple_policy_envelope)
{-
Type declaration of the Password validator - needs to match the tag inside file envelope.
The declaration is used as an additional check of compatibility with onchain (plutarch+ply specifically).
See the ply-ctl documentation for more elaborate examples:
https://github.com/mlabs-haskell/ply-ctl
-}
type PasswordValidator =
  TypedScript
    ValidatorRole -- We must annotate the Role of the script (ValidatorRole/MintingPolicyRole)
    (Cons (AsData ByteArray) Nil) -- A TypeLevel list of the arguments to the validator-construction function

-- The validator, constructed by applying a password String argument
makePasswordValidator :: ByteArray -> Either String Validator
makePasswordValidator pw = do
  val <- typed_password_validator
  case applyParam val pw of
    Left err -> throwError (show err)
    Right applied -> pure <<< toValidator $ applied

-- The validator, typed. 
-- 
-- This should be considered an alternative to the untyped 
-- password_validator :: Maybe PlutusScript
-- from the Script.purs module.
typed_password_validator :: Either String PasswordValidator
typed_password_validator = do
  reifyScriptEnvelope password_validator_envelope

{-
Type declaration of the Simple Policy minting policy - needs to match the tag inside file envelope.
The declaration is used as an additional check of compatibility with onchain (plutarch+ply specifically).
See the ply-ctl documentation for more elaborate examples:
https://github.com/mlabs-haskell/ply-ctl
-}
type SimplePolicy =
  TypedScript
    MintingPolicyRole
    (Cons (AsData TokenName) Nil)

{-
Function that constructs a MintingPolicy from a String.
-}
makeSimplePolicy :: TokenName -> Either String MintingPolicy
makeSimplePolicy tkNm = do
  policy <- typed_simple_policy
  case applyParam policy tkNm of
    Left err -> throwError (show err)
    Right applied -> pure (toMintingPolicy applied)

typed_simple_policy :: Either String SimplePolicy
typed_simple_policy = do
  reifyScriptEnvelope simple_policy_envelope

toValidator :: TypedScript ValidatorRole Nil -> Validator
toValidator = toPlutusScript >>> Validator

toMintingPolicy :: TypedScript MintingPolicyRole Nil -> MintingPolicy
toMintingPolicy = toPlutusScript >>> PlutusMintingPolicy

-- The function decodes the argument string as a script envelope (some json schema), 
-- and verifies that the saved script was tagged with a matching Type.
-- 
-- Broader picture: Plutarch scripts are ofc typed, ply saves Plutarch scripts storing the type info,
-- this function here is plumbing on purescript side to restore type info and ply-ctl library is used for that.
reifyScriptEnvelope ::
  forall (role :: ScriptRole) (params :: TyList Type)
   . ReifyRole role => ReifyParams params
  => 
  String -> Either String (TypedScript role params)
reifyScriptEnvelope scriptEnvelope = do
  decodedEnvelope <- lmap (\e -> "JSON decode error: " <> show e) $ do
    -- First, we have to decode the JSON String that represents the script envelope to Aeson
    aeson <- parseJsonStringToAeson scriptEnvelope
    -- Next, we decode the Aeson into a TypedScriptEnvelope
    decodeAeson aeson :: _ TypedScriptEnvelope

  -- Next, we use ply-ctl's reifiction machinery to read the typed envelope.
  -- This will throw an error of the argument types or role  in the envelope do not correspond to
  -- the types we declared in our PasswordValidator type (see above)
  lmap (\e -> "Script type mismatch: " <> show e) $
    reifyTypedScript decodedEnvelope
